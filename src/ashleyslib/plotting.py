import matplotlib.pyplot as plt
import pandas as pd
import numpy as np


#general parameters for plots
color_class1 = '#abd9e9'  # light blue
color_class1_dark = '#2c7bb6' #blue
color_class0 = '#fdae61'  # orange
color_class0_dark = '#d7191c' #red


def add_plotting_parser(subparsers):
    parser = subparsers.add_parser('plot', help='create plots for produced data')
    # for any plot type, you can add the annotation file to color the two groups differently
    parser.add_argument(
        '--annotation',
        '-a',
        default=None,
        help='annotation file for comparing predictions'
    )
    parser.add_argument(
        '--probabilities',
        '-p',
        default=None,
        help='file with prediction probabilities'
    )
    parser.add_argument(
        '--output_file',
        '-o',
        help='name of output file (.png or .jpg or .pdf)',
        required=True
    )

    parser_group_comp = parser.add_argument_group('Plot the distribution of a small set of features')
    parser.add_argument(
        '--feature_table',
        '-ft',
        default=None,
        help='feature table of cells to plot'
    )
    parser.add_argument(
        '--feature_list',
        '-fl',
        default=None,
        help='list of features to plot'
    )
    parser_group_comp.add_argument('--compare', '-c', help='plot feature list and compare it to those features')
    parser_group_comp.add_argument('--compare_annotation', '-ca', help='annotation file for comparing data')

    parser_group_w = parser.add_argument_group('Plot Watson distribution for ')
    parser_group_w.add_argument(
        '--w_percentage',
        '-w',
        help='file with Watson percentage for each considered window'
    )

    parser.set_defaults(execute=run_plotting)

    return subparsers


def plot_feature_distribution(feature_table, feature_list, annotation, output):
    """
    plot the distribution of specific features within a range of 0 to 1 (or specify the range manually?)
    specify bins manually?
    if the annotation is available: add different color schemes for class 0 and class 1 cells
    :param feature_table: feature table generated by feature_generation.py
    :param feature_list: list of features to consider for this plot
    :param annotation: annotation file (.txt) with the ids of class 1 cells
    :param output: name of output file (.png or .jpg or .pdf)
    :return:
    """

    #general plotting settings
    alpha = 0.8
    a, b = (0, 1) #plotted feature range
    bin_size = 0.01
    max_y_value = 100

    features = pd.read_csv(feature_table, sep='\s+')
    class_one_features = []
    class_zero_features = []
    if annotation:
        with open(annotation) as ann:
            annotation_list = [line.rstrip() for line in ann]
        class_one_features = features[features['sample_name'].isin(annotation_list)]
        class_zero_features = features[~features['sample_name'].isin(annotation_list)]

    plt.clf()
    fig, axs = plt.subplots(1, len(feature_list))
    plt.subplots_adjust(hspace=0.35, wspace=0.25) #TODO: values still working for more/less features?

    for i in range(len(feature_list)):
        axs[i].set_xlim(a, b)
        bin_list = np.arange(a, b, bin_size)
        axs[i].set_ylim(0, max_y_value)
        axs[i].spines['top'].set_visible(False)
        axs[i].spines['right'].set_visible(False)
        if annotation:
            axs[i].hist(class_one_features[feature_list[i]], alpha=alpha, bins=bin_list, label='Class 1',
                              color=color_class1)
            axs[i].hist(class_zero_features[feature_list[i]], alpha=alpha, bins=bin_list, label='Class 0',
                              color=color_class0)
        else:
            axs[i].hist(features[feature_list[i]], bins=bin_list)

        axs[i].set_xlabel(feature_list[i])
        axs[i].set_ylabel('Cell count')

    axs[len(feature_list)-1].legend(loc='upper right')

    fig.set_size_inches(16, 6) #check values for different number of features
    plt.savefig(output, bbox_inches='tight')
    return


def plot_w_distribution(w_percentage_list, sample_names, output):
    """
    plot the distribution of Watson percentage across all windows
    display the W10, W20,... steps of the features with vertical lines
    specify bins manually?
    :param w_percentage_list: file containing the values of Watson percentage for every window, generated by
    feature_generation.py with --output_plotting
    :param sample_names: ids of the samples or row numbers to use from w_percentage_list
    each value results in a new plot
    :param output: name of output file (.png or .jpg or .pdf)
    :return:
    """
    raise NotImplementedError


def plot_prediction_distribution(probabilities, annotation, output):
    """
    plot the distribution of the predicted class values for all cells
    :param probabilities: file with prediction probabilities prediction.tsv, generated by prediction.py
    :param annotation: annotation file with the ids of class 1 cells
    :param output: name of output file  (.png or .jpg or .pdf)
    :return:
    """
    raise NotImplementedError


def plot_feature_correlation(feature_table, feature_list, annotation, output):
    """
    scatterplot displaying the feature correlation of the features in feature_list
    :param feature_table: feature table generated by feature_generation.py
    :param feature_list: list of features to plot (scatterplot created for all pairwise features)
    :param output: name of output file  (.png or .jpg or .pdf)
    :return:
    """

    features = pd.read_csv(feature_table, sep='\s+')

    class_one_features = []
    class_zero_features = []
    if annotation:
        with open(annotation) as ann:
            annotation_list = [line.rstrip() for line in ann]
        class_one_features = features[features['sample_name'].isin(annotation_list)]
        class_zero_features = features[~features['sample_name'].isin(annotation_list)]

    plt.clf()
    fig, axs = plt.subplots(1, len(feature_list)-1)
    plt.subplots_adjust(hspace=0.35, wspace=0.25)  # TODO: values still working for more/less features?

    for i in range(len(feature_list)-1):
        axs[i].set_xlim(0, 1)
        #bin_list = np.arange(a, b, bin_size)
        axs[i].set_ylim(0, 1)
        axs[i].spines['top'].set_visible(False)
        axs[i].spines['right'].set_visible(False)

        if annotation:
            axs[i].scatter(class_one_features[feature_list[i]], class_one_features[feature_list[i + 1]],
                           c = color_class1, label='Class 1')
            axs[i].scatter(class_zero_features[feature_list[i]], class_zero_features[feature_list[i + 1]],
                           c = color_class0, label='Class 0')
        else:
            axs[i].scatter(features[feature_list[i]], features[feature_list[i+1]])

        axs[i].set_xlabel(feature_list[i])
        axs[i].set_ylabel(feature_list[i+1])

    axs[len(feature_list) - 2].legend(loc='upper right')

    fig.set_size_inches(10*(len(feature_list)-1), 10)  # check values for different number of features
    plt.savefig(output, bbox_inches='tight')
    return


def run_plotting(args):

    if args.w_percentage:
        dataframe = open(args.w_percentage, 'r')
        lines = dataframe.readlines()
        values = [161, 1576]
        for i in values:
            line = lines[i].replace('\n', '')
            w_percentage = line.split('\t')
            w_percentage = [float(x) for x in w_percentage]
            output_file = output[:(len(output)-4)] + '_' + str(i) + output[(len(output)-4):]
            plot_wc_distribution(w_percentage, output_file)
    if args.probabilities:
        plot_prediction_distribution(args.probabilities, args.annotation, args.output_file)

    if args.feature_table:
        feature_list = ['total_0.2mb', 'total_0.4mb', 'W90_2.0mb', 'total_0.6mb', 'W100_2.0mb']  # svc comb6
        # feature_list = ['total_0.4mb', 'W70_5.0mb', 'W90_2.0mb', 'W100_5.0mb', 'W20_0.6mb']  # gb comb6
        if args.feature_list:
            feature_list = args.feature_list
        plot_feature_distribution(args.feature_table, feature_list, args.annotation, args.output_file)
        plot_feature_correlation(args.feature_table, feature_list, args.annotation, args.output_file)

    return
